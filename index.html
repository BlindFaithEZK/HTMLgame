<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gridshot Prototype</title>
<style>
html, body { margin:0; padding:0; background:#0b0e1a; color:#fff; font-family: 'Exo 2', 'Roboto', system-ui, sans-serif; overflow:hidden; height:100%; }
canvas { display:block; touch-action: manipulation; }
#hud { position:fixed; top:8px; left:50%; transform:translateX(-50%); display:flex; gap:16px; font-size:18px; font-weight:bold; text-shadow:1px 1px 2px black; pointer-events:none; transition:transform 0.1s ease; }
#endScreen { position:fixed; inset:0; background:rgba(11,14,26,0.95); display:none; flex-direction:row; align-items:center; justify-content:space-around; gap:50px; text-align:center; padding:20px; }
#endStats { display:flex; flex-direction:column; gap:16px; font-size:20px; font-weight:bold; text-shadow:1px 1px 2px black; }
#modeButtons { display:flex; flex-direction:column; gap:12px; }
#restart { padding:14px 26px; border-radius:999px; border:none; background:#4f7cff; color:white; font-size:18px; cursor:pointer; }
.modeBtn { padding:12px 24px; border:none; border-radius:999px; background:#4f7cff; color:white; font-size:16px; cursor:pointer; }
.newBest { color:#00ff6a; font-weight:bold; }
.accuracyUp { color:#00ff6a; font-weight:bold; transition:color 0.2s ease, transform 0.2s ease; }
.accuracyDown { color:#ff4f6d; font-weight:bold; transition:color 0.2s ease, transform 0.2s ease; }
#startScreen { position: fixed; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-size:32px; cursor:pointer; background: rgba(0,0,0,0.85); z-index:10; gap:20px; }
</style>
<link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@700&display=swap" rel="stylesheet">
</head>
<body>
<canvas id="game"></canvas>

<div id="hud">
  <div id="hits">Hits: 0</div>
  <div id="acc">Acc: 100%</div>
  <div id="kpm">KPM: 0</div>
  <div id="time">60</div>
</div>

<div id="endScreen">
  <div id="endStats">
    <div id="finalHits"></div>
    <div id="finalAcc"></div>
    <div id="finalKPM"></div>
    <button id="restart">Replay</button>
  </div>
  <div id="modeButtons">
    <button class="modeBtn" data-mode="30">30s Challenge</button>
    <button class="modeBtn" data-mode="60">Gridshot 60s</button>
    <button class="modeBtn" data-mode="90">90s Challenge</button>
    <button class="modeBtn" data-mode="endless">Endless Mode</button>
  </div>
</div>

<div id="startScreen">
  <div>Click to Start Gridshot</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const hitsEl = document.getElementById('hits');
const accEl = document.getElementById('acc');
const kpmEl = document.getElementById('kpm');
const timeEl = document.getElementById('time');

const endScreen = document.getElementById('endScreen');
const finalHitsEl = document.getElementById('finalHits');
const finalAccEl = document.getElementById('finalAcc');
const finalKPMEl = document.getElementById('finalKPM');
const restartBtn = document.getElementById('restart');
const modeButtons = document.querySelectorAll('.modeBtn');
const startScreen = document.getElementById('startScreen');

function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

const GRID = 5;
let ROUND_TIME = 60;
let targets = [];
let hits = 0, shots = 0, timeLeft = ROUND_TIME, running = false, intensity = 1;
let bestHits = Number(localStorage.getItem('bestHits')) || 0;
let bestAcc = Number(localStorage.getItem('bestAcc')) || 0;
let bestKPM = Number(localStorage.getItem('bestKPM')) || 0;
let endlessMode = false;

function spawnTarget() {
    const w = canvas.width / GRID;
    const h = canvas.height / GRID;
    const cell = { col: Math.floor(Math.random()*GRID), row: Math.floor(Math.random()*GRID) };
    const target = { x: cell.col*w + w/2, y: cell.row*h + h/2, r: Math.max(35, Math.min(w,h)*0.22), scale:0, scaleSpeed:6 };
    targets.push(target);
}

function reset() {
    targets = [];
    hits = 0;
    shots = 0;
    timeLeft = ROUND_TIME;
    intensity = 1;
    running = true;
    endScreen.style.display = 'none';
    spawnTarget(); spawnTarget(); spawnTarget();
}

canvas.addEventListener('pointerdown', e => {
    if(!running) return;
    shots++;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    let hit = false;
    for(let i = targets.length-1; i>=0; i--) {
        const t = targets[i];
        if(Math.hypot(x-t.x, y-t.y) < t.r * t.scale) {
            targets.splice(i,1);
            hits++;
            intensity += 0.1;
            spawnTarget();
            hit = true;
            break;
        }
    }
});

let prevAcc = 100;
let last = performance.now();

function update(dt) {
    if(!endlessMode) timeLeft -= dt;
    if(timeLeft <= 0) { timeLeft = 0; endRound(); }
    targets.forEach(t => { t.scale += dt*t.scaleSpeed; if(t.scale>1) t.scale=1; });
}

function draw() {
    // Gradient background
    const bg = ctx.createRadialGradient(canvas.width/2, canvas.height/2,0,canvas.width/2,canvas.height/2,canvas.width/1.5);
    bg.addColorStop(0,'#0b1026');
    bg.addColorStop(1,'#050712');
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    const gridSize = 80;
    for(let x=0;x<canvas.width;x+=gridSize){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
    for(let y=0;y<canvas.height;y+=gridSize){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}

    targets.forEach(t => { ctx.beginPath(); ctx.arc(t.x,t.y,t.r*t.scale,0,Math.PI*2); ctx.fillStyle='#ff4f6d'; ctx.fill(); });
}

function endRound() {
    running = false;
    const acc = shots ? Math.round((hits/shots)*100) : 100;
    const kpm = Math.round((hits/(ROUND_TIME-timeLeft || 1))*60);
    finalHitsEl.innerHTML = `Hits: ${hits}${hits>bestHits?' <span class="newBest">NEW BEST!</span>':''}`;
    finalAccEl.innerHTML = `Accuracy: ${acc}%${acc>bestAcc?' <span class="newBest">NEW BEST!</span>':''}`;
    finalKPMEl.innerHTML = `KPM: ${kpm}${kpm>bestKPM?' <span class="newBest">NEW BEST!</span>':''}`;
    bestHits = Math.max(bestHits, hits); bestAcc = Math.max(bestAcc, acc); bestKPM = Math.max(bestKPM, kpm);
    localStorage.setItem('bestHits', bestHits); localStorage.setItem('bestAcc', bestAcc); localStorage.setItem('bestKPM', bestKPM);
    endScreen.style.display = 'flex';
}

function loop(now) {
    const dt = (now-last)/1000; last = now;
    if(running) update(dt);
    const acc = shots ? Math.round((hits/shots)*100) : 100;
    if(acc>prevAcc){ accEl.className='accuracyUp'; } else if(acc<prevAcc){ accEl.className='accuracyDown'; } else { accEl.className=''; }
    prevAcc = acc;
    const kpm = timeLeft<ROUND_TIME ? Math.round((hits/(ROUND_TIME-timeLeft||1))*60):0;
    hitsEl.textContent = `Hits: ${hits}`;
    accEl.textContent = `Acc: ${acc}%`;
    kpmEl.textContent = `KPM: ${kpm}`;
    timeEl.textContent = Math.ceil(timeLeft);
    draw();
    requestAnimationFrame(loop);
}

startScreen.addEventListener('click', () => { startScreen.style.display='none'; reset(); });
restartBtn.addEventListener('click', reset);
modeButtons.forEach(btn => {
    btn.addEventListener('click', () => {
        const mode = btn.dataset.mode;
        if(mode==='endless'){ endlessMode=true; ROUND_TIME=9999; timeLeft=ROUND_TIME; }
        else { endlessMode=false; ROUND_TIME=parseInt(mode); timeLeft=ROUND_TIME; }
        endScreen.style.display='none';
        reset();
    });
});

requestAnimationFrame(loop);
</script>
</body>
</html>
